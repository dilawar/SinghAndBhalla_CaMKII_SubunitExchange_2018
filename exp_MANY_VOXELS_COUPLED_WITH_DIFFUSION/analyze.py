#!/usr/bin/env python3
"""
analyze.py: Analyze data generated by CaMKII/PP1 switch simulations.
"""
    
__author__           = "Dilawar Singh"
__copyright__        = "Copyright 2015, Dilawar Singh and NCBS Bangalore"
__credits__          = ["NCBS Bangalore"]
__license__          = "GNU GPL"
__version__          = "1.0.0"
__maintainer__       = "Dilawar Singh"
__email__            = "dilawars@ncbs.res.in"
__status__           = "Development"

import os
import numpy as np
import pandas as pd
import scipy
import sys
import datetime
import csv
import re
import subprocess
import helper

stamp = datetime.datetime.now().isoformat()

import matplotlib as mpl
mpl.use( 'Agg' )
import matplotlib.pyplot as plt
#try:
#    mpl.style.use( 'seaborn-talk' )
#except Exception as e:
#    pass
mpl.rcParams['axes.linewidth'] = 0.2
mpl.rcParams['lines.linewidth'] = 0.6
mpl.rc('text', usetex=True)
# mpl.rc('font', family='serif')
mpl.rc('font', size=10)
mpl.rc('xtick', labelsize=8) 
mpl.rc('ytick', labelsize=8) 
import matplotlib.ticker as ticker


try:
    gitHash = subprocess.check_output(
            ["git", "log", "--pretty=format:'%h'", "-n", "1" ]
            )
except Exception as e:
    gitHash = 'Unknown'

startN_ = 0
finalN_ = 0

binW_ = 1

now_ = datetime.datetime.today().ctime()
title_ = r' \text{Git# %s, @ %s} ' % ( gitHash, now_ )

timeUnit = 'hour' 
if timeUnit == 'year':
    scaleT_ = 1.0 / (365*24*3600)
elif timeUnit == 'month':
    scaleT_ = 1.0 / (30*24*365)
elif timeUnit == 'day':
    scaleT_ = 1.0 / (24*3600.0)
elif timeUnit == 'hour':
    scaleT_ = 1.0 / (3600.0)
else:
    timeUnit = 'second'
    scaleT_ = 1.0

def get_header( data_file ):
    with open( data_file, "r" ) as f:
        header = f.readlines(1)[0].strip()
    return [ x.replace('"', '') for x in  header.split(' ') ]

def analyze( tables ):
    vectors = {}
    for k in tables:
        vectors[k] = tables[k].vector

def merge_neighbours( vec, ignore_radius = 300):
    if len(vec) < 1:
        return []
    newVec = [ vec[0] ]
    for i, v in enumerate( vec[1:] ):
        if v - vec[i] > ignore_radius:
            newVec.append( v )
    return newVec

def get_overlapping_intervals( intevals ):
    xs, ys = [], []
    for x, y in intevals:
        if y not in ys:
            xs.append(x); ys.append(y)
    return zip(xs, ys)

def find_intervals( low_ps, high_ps ):
    intervals = []
    for lowP in low_ps:
        # print('[DEBUG] Checking for interval starting at %s' % lowP )
        highPs = filter(lambda x: x > lowP, high_ps)
        if highPs:
            intervals.append((lowP, highPs[0]-1))
        else:
            intervals.append((lowP, finalN_))
    return get_overlapping_intervals(intervals)

def get_points_where( array, val, distance = 1 ):
    """ Get indices I where  for every i in I, array[i] == val 

    Also remove indices which are separated by 'distance'.
    """
    ps, = np.where( array == val )
    if len(ps) == 0:
        return []
    newps = [ ps[0] ]
    for i, p in enumerate(ps[1:]):
        if p - ps[i] > distance:
            newps.append( p )
    return newps

def find_transitions( vec ):
    """
    Find transitions in given vec. 
    """
    pass 


def plot_histogram( ax, data, label, density = False, **kwargs ):
    nbins = int(kwargs.get('bins', 1+data.max())) 
    try:
        ax.hist(data, bins=nbins, normed=density
                , alpha=0.8, range=(0,nbins))
        axtemp = ax.twinx()
        axtemp.hist( data, bins = nbins, normed = density
                , range=(0,nbins)
                , color = 'red', cumulative = True 
                , histtype = 'step', alpha = 0.8
                )
    except Exception as e:
        print( 'Failed to plot histogram %s' % label )
        print( '\tError was %s' % e )
    ax.set_title( label  )

def smooth( data, window_size = 20 ):
    window = np.ones( window_size ) / window_size 
    return np.convolve( data, window, 'same' )

def computeHighIntervals( tvec, yvec ):
    thresH = yvec.max( ) / 2.0
    thresL = 1
    startT, endT = 0, 0
    intervalStarted = False
    slices = [ ]
    for i, v in enumerate( yvec ):
        if not intervalStarted and v > thresH:
            startT = tvec[ i ]
            intervalStarted = True
        if intervalStarted and v < thresH:
            intervalStarted = False
            endT = tvec[i]
            slices.append( ( startT, endT ) )
    return slices


    
def process( data, args ):
    global startT_, finalN_
    print('[INFO] Processing data for low-camkii')
    # pdf_ = PdfPages( args.output or '%s.pdf' % args.input ) 
    outfile = args.output or '%s.png' % args.input 
    fig = plt.figure( figsize=(12,12)  )

    ax11 = plt.subplot2grid((5,3), (0,0), colspan=2)
    ax12 = plt.subplot2grid((5,3), (0,2), colspan=1)
    ax21 = plt.subplot2grid((5,3), (1,0), colspan=2)
    ax22 = plt.subplot2grid((5,3), (1,2), colspan=1)

    ax31 = plt.subplot2grid((5,3), (2,0), colspan=1)
    ax32 = plt.subplot2grid((5,3), (2,1), colspan=1)
    ax33 = plt.subplot2grid((5,3), (2,2), colspan=1)
    ax41 = plt.subplot2grid((5,3), (3,0), colspan=1)
    ax42 = plt.subplot2grid((5,3), (3,1), colspan=1)
    ax43 = plt.subplot2grid((5,3), (3,2), colspan=1)

    ax51 = plt.subplot2grid((5,3), (4,0), colspan=1)
    ax52 = plt.subplot2grid((5,3), (4,1), colspan=1)

    # Frist drop any spurious colum with all NaN 
    data = data.dropna( 1, 'all' )
    # Drop any row with one or more NaN values.
    data = data.dropna( )
    # Drop first row in any case.
    data.drop( data.index[[0]], inplace=True )


    # Always drop index 0 row from dataframe.
    data.drop( data.index[[0]], inplace=True )

    # New dataframe.
    df = pd.DataFrame( )
    df[ 'time' ] = data[ 'time' ]

    tVec, camkii0, camkii1 = data['time'], [], []
    tVec = np.array( tVec ) * scaleT_
    finalN_ = len(tVec) - 1

    trans = []
    lowCaM6, lowCaM7 = [], []
    camkii6, camkii7 = [], []
    nonzeroCaMKII = [ ]
    allCaMKII = [ ]
    ca = []
    for k in data.columns:
        m = re.search( r'x(\d)y(\d)', k )
        if m:
            x = int( m.group( 1 ) )
            y = int( m.group( 2 ) )
            allCaMKII.append( data[k] )
            if x + y == 6:
                camkii6.append( data[ k ] )
            elif x + y == 7:
                camkii7.append( data[ k ] )

        if re.search( r'x0y6(\[\d+\])?\.N', k):
            lowCaM6.append( data[k] )
        elif re.search( r'x0y7(\[\d+\])?\.N', k):
            lowCaM7.append( data[k] )

        if re.search( r'x[3-7]y\d(\[\d+\])?\.N', k):
            nonzeroCaMKII.append( data[k] )

        if re.search( r'(x6y0|x7y0)(\[\d+\])?\.N', k):
            camkii1.append( data[k] )
            # ax2.plot( tVec, data[k], label = k, alpha=0.6 )
        if re.search( r'ca(\[\d+\])?\.N', k):
            ca.append( data[k] )

    lowCaMKII = np.sum( lowCaM6, axis = 0 ) + np.sum( lowCaM7, axis=0 )
    highCaMKII = np.sum( nonzeroCaMKII, axis = 0 )
    df[ 'CaMKII*' ] = highCaMKII

    # Compute transitions in highCaMKII.
    _max = int(highCaMKII.max())
    _t = int(_max/10)
    kt = helper.compute_karmer_time( highCaMKII, [0, _max], [_t,_t] )
    st = helper.compute_transitions( highCaMKII, [0, _max], [_t,_t] )
    print( ' Kramer time %s' % kt )
    print( ' Number of down transitions  %d' % int(len(st)/2) )

    allCaMKII = np.sum( allCaMKII, axis = 0 )
    ax11.set_title( 'Active CaMKII',  )
    ax11.plot( tVec, highCaMKII )
    ax11.set_xlabel( 'Time (%s)' % timeUnit )
    ax11.legend(fontsize=4)

    try:
        allCaMKII6 = np.sum( camkii6, axis=0 )
        df[ 'CaMKII6' ] = allCaMKII6
        ax11.plot( tVec, allCaMKII6, alpha=0.5, label="CaMKII6" );
        ax11.legend(fontsize=4)
    except Exception as e:
        print( 'Could not plot CaMKII(6) and CaMKII(7)' )
        print( '\tError was %s' % e )

    try:
        allCaMKII7 = np.sum( camkii7, axis=0)
        df[ 'CaMKII7'] = allCaMKII7
        ax11.plot( tVec, allCaMKII7, alpha=0.5, label = 'CaMKII7')
        ax11.set_title( r'Avg. ratio of CaMKII7 and CaMKII6 = %f' % 
                ( float(np.sum( allCaMKII7)) / np.sum( allCaMKII6 ) ) 
                )
        ax11.legend(fontsize=4)
        
    except Exception as e:
        print( 'Could not plot CaMKII(6) and CaMKII(7)' )
        print( '\tError was %s' % e )

    plot_histogram( ax12, highCaMKII, 'Active CaMKII',  True )

    camkiiAll0 = np.sum( camkii0, axis = 0 )
    print( 'Total %d compartment(s) with camkii' % len( camkii0 ))
    camkiiAllLow = np.sum( camkii0, axis = 0 )
    camkiiAllHigh = np.sum( camkii1, axis = 0 )

    print( '[INFO] Total camkii: min=%s, max=%s, avg=%s' % ( 
        camkiiAll0.min(), camkiiAll0.max(), camkiiAll0.mean( ) )
        )

    pp1, camPP1Cplx, i1p, i1ppp1 = [ ], [ ], [ ], [ ]
    xs, ys = [ ], [ ]

    for k in data.columns:
        if re.search( r'\.PP1(\[\d+\])?\.N', k):
            pp1.append( data[k] )
            ax21.plot(tVec, smooth(data[k]), label=k, alpha=0.5)
            ax21.legend()
        elif re.search( r'\.x(\[\d+\])?\.N', k):
            xs.append( data[k] )
        elif re.search( r'\.y(\[\d+\])?\.N', k):
            ys.append( data[k] )
        elif re.search( r'\.I1PPP1(\[\d+\])?\.N', k):
            i1ppp1.append( data[k] )
        elif re.search( r'\.I1P(\[\d+\])?\.N', k):
            i1p.append( data[k] )

    pp1 = np.sum( pp1, axis = 0 )
    df['PP1'] = pp1

    #  ax21.plot( tVec, pp1,  label='All PP1' )
    try:
        ax21.plot(tVec, smooth(pp1, 60), lw=2, label = 'Smooth PP1')
    except Exception as e:
        print( "[WARN ] Erorr %s" % e )

    ax21.set_xlabel( 'Time (%s)'% timeUnit )
    ax21.set_title( 'Active PP1',  )
    ax21.legend(fontsize=4)
    plot_histogram( ax22, pp1, 'All PP1' )

    if max( tVec ) < 86400:
        ax31.plot( tVec, np.mean(ca, axis=0), alpha = 0.8 )
        ax31.set_xlabel( 'Time (%s)'% timeUnit,  )
        ax31.set_ylabel( 'No of molecules' )
        ax31.set_title('Ca',  )
    else:
        ax31.plot( tVec[100:120], np.mean(ca, axis=0)[100:120], alpha = 0.8 )
        ax31.set_xlabel( 'Time (%s)'% timeUnit,  )
        ax31.set_ylabel( 'No of molecules' )
        ax31.set_title('Ca (zoom)',  )

    if len(xs) > 0 or len(ys) > 0:
        for i, x in enumerate(xs):
            #  ax32.plot( tVec, x, '-.', alpha = 0.6, label = 'x%d' % i )
            ax32.plot( tVec, smooth(x, 30), alpha = 0.6, label = 'x%d' % i )
            ax51.hist( x, range=(0,max(x)), bins = max(x)+1, histtype='step', label='x%d' % i )
        for i, y in enumerate(ys):
            ax33.plot( tVec, smooth(y, 30), alpha = 0.6, label = 'y%d' % i )
            ax52.hist( y, range=(0,max(x)), bins = max(y)+1, histtype='step',
                    label='y%d' % i )

        for ax in [ ax32, ax33, ax51, ax52]:
            ax.legend(fontsize=4)

        ax32.set_title( 'x (lowpassed 30 mins)' )
        ax51.set_title( 'x (lowpassed 30 mins)' )
        ax33.set_title( 'y (lowpassed 30 mins)' )
        ax52.set_title( 'y (lowpassed 30 mins)' )

        allX = np.sum( xs, axis = 0 )
        allY = np.sum( ys, axis = 0 )
        df[ 'x' ] = allX
        df[ 'y' ] = allY
    else:
        print( '[INFO] No subunit exchange' )
        
    ### INTERMEDIATE SPECIES.
    i1p = np.sum( i1p, axis = 0 )
    ax41.plot( tVec, i1p, alpha = 0.2 )
    try:
        ax41.plot( tVec, smooth(i1p, 100) )
    except Exception as e:
        pass
    ax41.set_xlabel( 'Time (%s)' % timeUnit )
    ax41.set_title( 'I1P',  )

    try:
        i1ppp1 = np.sum( i1ppp1, axis = 0 )
        ax42.plot( tVec, i1ppp1, alpha = 0.2 )
        try:
            ax42.plot( tVec, smooth(i1ppp1, 200) )
        except Exception as e:
            pass
        ax42.set_title( 'I1P.PP1',  )
        ax42.set_xlabel( 'Time (%s)' % timeUnit )
    except Exception as e:
        print( 'Failed to plot i1ppp1. Error was %s' % e )
        pass

    vec = i1ppp1 + pp1
    ax43.plot( tVec, vec.max( ) - vec )
    ax43.set_xlabel( 'Time (%s)' % timeUnit )
    ax43.set_title( 'PP1 in other cmplx'  )

    # Plot the sum of inactive PP1 and active PP1.
    # plt.suptitle(
    #         r'\text{%s} ' % os.path.basename( args.input ) + title_
    #         , , x = 0.5, y = 0.02
    #         )
    plt.tight_layout( rect = [0, 0, 1.0, 0.95] )

    # Put extra info in suptitle
    plt.suptitle( r'Kramer Time (LOW)=%.4f, Number of $\downarrow$=%d' % ( 
        kt[0], int(len(st) / 2) ) )
    plt.savefig( outfile )
    print( ' + Saved to %s' % outfile  )

    # Write the accumulated data to a file.
    outfile = '%s_processed.dat' % args.input 
    df.to_csv( outfile, sep = ' ', index = False )
    print( 'Wrote summary data to %s' % outfile )
    
def read_data( args ):
    filename = args.input
    ext = filename.split('.')[-1]
    data = {}
    header = get_header( filename )
    data = pd.read_csv( filename, comment='#', delimiter = ' ' )
    return data


def main( args ):
    try:
        data = read_data( args )
    except Exception as e:
        print( '[ERROR] Failed to read data file' )
        print( '\t Error was %s' % e )
        return 

    process( data, args)

if __name__ == '__main__':
    import argparse
    # Argument parser.
    description = '''Argument parser'''
    parser = argparse.ArgumentParser(description=description)
    parser.add_argument('--input', '-i'
        , required = True
        , help = 'Input file'
        )
    parser.add_argument('--output', '-o'
        , required = False
        , default = False
        , help = 'Output file'
        )
    parser.add_argument( '--debug', '-d'
        , required = False
        , default = 0
        , type = int
        , help = 'Enable debug mode. Default 0, debug level'
        )
    parser.add_argument('--title', '-title'
        , default = title_
        , help = 'Title of the plot'
        )
    class Args: pass 
    args = Args()
    parser.parse_args(namespace=args)
    main( args )
